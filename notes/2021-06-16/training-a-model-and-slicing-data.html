<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../style.css">
<title>training-a-model-and-slicing-data</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Notes for June 16"><h1 id="Notes for June 16" class="header"><a href="#Notes for June 16">Notes for June 16</a></h1></div>

<ul>
<li>
Should we slice the C chirps or not?

<ul>
<li>
C chirps are concatenations of A and Bs, and they are labeled as Cs
      because Nate sees repeat patterns of Cs, indicating that they are a
      difficult class to label

<li>
TBD - Let's train a model first and see what the drawbacks are of clipping
      vs not clipping.

</ul>
</ul>
 
<ul>
<li>
Different ways of batching:

<ul>
<li>
Pad to largest sequence in batch

<li>
Clip to smallest sequence in batch

<li>
Don't clip or pad, just use a batch size of 1 (slow!)

</ul>
</ul>
 
<ul>
<li>
<span class="todo">TODO</span>:

<ul>
<li>
Queue examples from different classes [optional]

<li>
Cut off low frequency noise and make sure the difference between high and
      low signals is stark (in our new spectrogram)

<li>
Decide whether or not to play around with the Spectrogram parameters

<li>
Finish dataloader

</ul>
</ul>

<p>
<span id="Notes for June 16-Fixing the MelSpectrogram"></span><strong id="Fixing the MelSpectrogram">Fixing the MelSpectrogram</strong>
</p>

<p>
We had issues with NaNs and infs in the spectrogram (function arguments below).
</p>

<pre python>
    torchaudio.transforms.MelSpectrogram(sample_rate: int = 16000, n_fft: int = 400,
    win_length: Optional[int] = None, hop_length: Optional[int] = None, f_min: float
    = 0.0, f_max: Optional[float] = None, pad: int = 0, n_mels: int = 128,
    window_fn: Callable[[...], torch.Tensor] = &lt;built-in method hann_window of type
    object&gt;, power: Optional[float] = 2.0, normalized: bool = False, wkwargs:
    Optional[dict] = None, center: bool = True, pad_mode: str = 'reflect', onesided:
    bool = True, norm: Optional[str] = None, mel_scale: str = 'htk') 
</pre>

<p>
The reason why (we think...) is because low-frequency signal wasn't being picked
up by the DFFTs applied in the MelSpectrogram. So we increased the length of the
DFFTs to 1600 (from 400). In order to preserve the spectrogram's resolution we
manually set the window_length to 200. <span id="Notes for June 16-This increased the runtime dramatically."></span><strong id="This increased the runtime dramatically.">This increased the runtime dramatically.</strong>
It's up to Kayla to decide whether or not she wants to deal with the increased
runtime or just clip the NaNs and infs from the original MelSpectrogram (or use
a normal spectrogram).
</p>


<div id="Queueing examples from different classes"><h1 id="Queueing examples from different classes" class="header"><a href="#Queueing examples from different classes">Queueing examples from different classes</a></h1></div>
<p>
This is sometimes called Random Majority Undersampling or Random Minority
Oversampling, depending on the context.
</p>

<div id="Queueing examples from different classes-pseudocode"><h3 id="pseudocode" class="header"><a href="#Queueing examples from different classes-pseudocode">pseudocode</a></h3></div>
<pre python>
__init__
    a_idx = 0
    b_idx = 0

def __getitem__(self, idx):
    # hint: you can do this with just idx!

    a_examples = As[a_idx]
    b_examples = Bs[b_idx]
    
    a_idx = increment_idx_such_that_it_does_not_go_out_of_bounds_of_the_As(a_idx)
    b_idx = increment_idx_such_that_it_does_not_go_out_of_bounds_of_the_Bs(b_idx)

    return (a_examples, a_labels), (b_examples, b_labels)

</pre>

</body>
</html>
